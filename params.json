{
  "name": "Parallel-task-queue",
  "tagline": "",
  "body": "parallel-task-queue - Keep request process in sequence with configurable parallelism\r\n=====================================================\r\n\r\nParallel-task-queue is simple tool to keep requests to be executed in order with configurable parallelism.\r\n\r\nAs we known, Node.js has an event-driven architecture capable of asynchronous I/O  and  callbacks are unordered. But sometimes we may need the requests to be processed in order.\r\nSeq-queue takes the responsibility to make the asynchronous, unordered processing flow into serial and ordered.\r\n\r\nParallel-task-queue is a FIFO task queue and we can push tasks as we wish, anytime(before the queue closed), anywhere(if we hold the queue instance). A task is known as a function and we can do anything in the function and just need to call `task.done()` to tell the queue current task has finished.\r\n\r\n * Tags: node.js\r\n\r\n##Installation\r\n```\r\nnpm install parallel-task-queue\r\n```\r\n\r\n##Usage\r\n``` javascript\r\nlet TaskManager = require('parallel-task-queue');\r\n\r\nlet taskQueue = new TaskManager.TaskQueue({\r\n    globalTimeout:1000,\r\n    timeBeforeClose:2000,\r\n    paralleleTask:1\r\n});\r\n\r\nfor(let i = 0; i < 50;i++)\r\n{\r\n    taskQueue.push(task => {\r\n        setTimeout(() => {\r\n            task.done();\r\n        }, Math.floor(Math.random() * 1000));\r\n    }).then(data => {\r\n        console.log(`Task ${i} finished`);\r\n    }).catch(TaskManager.TaskTimeoutError, (e) => {\r\n            console.log(`Task Time out`)\r\n    }).catch(e => {\r\n        console.log(e)\r\n    })\r\n}\r\n\r\ntaskQueue.on(TaskManager.ALL_TASK_FINISHED_EVENT, () => {\r\n    console.log('All task finished')\r\n});\r\n\r\n```\r\n\r\n##API\r\n###`new TaskManager.TaskQueue(opt)`\r\nCreate a new  instance of TaskQueue. A global timeout value in ms for the new instance can be set by `timeout` parameter or use the default timeout (3s) by no parameter.\r\n####Arguments\r\n+ `opt.globalTimeout` - A global timeout value in ms (for the new instance) before processing next task.default value is `TASK_DEFAULT_TIMEOUT`\r\n+ `opt.timeBeforeClose` - if no task has been pushed in this duration, queue will be closed and new added task will be ignored. Default value is `TIME_OUT_BEFORE_CLOSE_QUEUE`\r\n+ `opt.paralleleTask` - Number of task to be executed at same time . Defaut value is `PARALLELE_TASK`\r\n\r\n###`TaskQueue.push(fn, timeout)`\r\nAdd a task into the queue instance.\r\n####Arguments\r\n+ `fn(task)` - The function that describes the content of task and would be invoke by queue. `fn` takes a arguemnt task and we *must* call task.done() to tell queue current task has finished.\r\n+ `timeout` - If specified, it would overwrite the global timeout that set by `new TaskManager.TaskQueue` for `fn`.\r\n\r\n###`TaskQueue.close()`\r\nClose the queue.\r\n\r\n##Event\r\nSeq-queue instances extend the EventEmitter and would emit events in their life cycles.\r\n###`BEGIN_FIRST_TASK_EVENT`\r\nEmited When starting first task\r\n###`TASK_FINISHED_EVENT`\r\nEmited each time one  task finished\r\n###`ALL_TASK_FINISHED_EVENT`\r\nEmit when all task finished\r\n\r\n```\r\n// All constant all member of `TaskManager` object\r\n\ttaskQueue.on(TaskManager.ALL_TASK_FINISHED_EVENT, () => {\r\n\t    console.log('All task finished')\r\n\t});\r\n```\r\n\r\n##Status\r\nTaskQueue has many life cycle with these value:\r\n###`TASK_NOT_START_YET_STATUS`\r\n### `TASK_RUNNING_STATUS`\r\n### `TASK_FINSHED_STATUS`\r\n\r\n## Getter\r\n## `TaskQueue.globalTimeout` - Number\r\n## `TaskQueue.status`\r\n## `TaskQueue.closed` - Boolean - if queue is closed\r\n## `TaskQueue.timeBeforeClose`\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}